# operator templates for nodes
##############################

# fre operator
fre_op:
  base: OperatorTemplate
  equations:
    - "inp = J*tau*s_in + eta + I_ext"
    - "inp_sq = absv(inp + sqrt(inp^2 + Delta^2))/2*pi"
    - "r' = (sqrt(inp_sq) - r) / tau"
  variables:
    r: output(0.0)
    inp: variable(0.0)
    inp_sq: variable(0.0)
    s_in: input(0.0)
    I_ext: input(0.0)
    tau: 1.0
    J: 10.0
    Delta: 1.0
    eta: 0.0

# qif operator
qif_op:
  base: OperatorTemplate
  equations:
    - "r' = (Delta/(pi*tau) + 2.0*r*v) / tau"
    - "v' = (v^2 - (pi*tau*r)^2 + tau*J*s_in + eta + I_ext) / tau"
  variables:
    r: output(0.0)
    v: variable(0.0)
    Delta: 0.1
    tau: 1.0
    J: 20.0
    eta: 0.0
    I_ext: input(0.0)
    s_in: input(0.0)

# synaptic operator
syn_op:
  base: OperatorTemplate
  equations:
    - "s' = (r-s)/tau_s"
  variables:
    s: output(0.0)
    r: input(0.0)
    tau_s: 0.5

# depressive synaptic operator
syn_sd_op:
  base: OperatorTemplate
  equations:
    - "s' = (a*r-s)/tau_s"
    - "a' = (1-a)/tau_a - kappa*a*r"
  variables:
    s: output(0.0)
    a: variable(1.0)
    r: input(0.0)
    tau_s: 0.5
    tau_a: 20.0
    kappa: 0.5

# facilitative synaptic operator
syn_sf_op:
  base: OperatorTemplate
  equations:
    - "s' = (a*r-s)/tau_s"
    - "a' = (A0-a)/tau_a + A0*(1-a)*r"
  variables:
    s: output(0.0)
    a: variable(0.0)
    r: input(0.0)
    tau_s: 0.5
    tau_a: 20.0
    A0: 0.5

# calcium trace operator
ca_op:
  base: OperatorTemplate
  equations:
    - "u' = (r-u)/tau_u"
  variables:
    u: output(0.0)
    r: input(0.0)
    tau_u: 100.0

# clopath operator
ik_clopath_op:
  base: OperatorTemplate
  equations:
    - "r' = (Delta*k/(pi*C) + r*(k*(2.0*v-v_r-v_t) - g_e*s_e - g_i*s_i)) / C"
    - "v' = (k*(v-v_r)*(v-v_t) - (pi*C*r)^2/k + g_e*s_e*(E_e-v) + g_i*s_i*(E_i-v) + eta + I_ext - u) / C"
    - "u' = (b*(v-v_r) - u + tau_u*kappa*ca)/tau_u"
    - "s' = r-s/tau_s"
    - "ca' = r-ca/tau_ca"
    - "v_ltd' = (v-v_ltd) / tau_ltd"
    - "v_ltp' = (v-v_ltp) / tau_ltp"
  variables:
    r: output(0.01)
    v: variable(-60.0)
    s: variable(0.0)
    u: variable(0.0)
    ca: variable(0.0)
    v_ltd: variable(0.0)
    v_ltp: variable(0.0)
    C: 100.0
    k: 0.7
    v_r: -60.0
    v_t: -40.0
    Delta: 1.0
    g_e: 1.0
    g_i: 1.0
    E_e: 0.0
    E_i: -65.0
    tau_u: 50.0
    tau_s: 5.0
    tau_ca: 150.0
    tau_ltd: 50.0
    tau_ltp: 50.0
    eta: 0.0
    kappa: 1.0
    I_ext: input(0.0)
    s_e: input(0.0)
    s_i: input(0.0)

# operator templates for edges
##############################

# Clopath's STDP rule
clopath_op:
  base: OperatorTemplate
  equations:
    - "w' = a_ltp*u_pre*sigmoid(gamma_ltp*(v_post_ltp-theta_ltd))*sigmoid(gamma_ltp*(v_post-theta_ltp)) - a_ltd*s_pre*sigmoid(gamma_ltd*(v_post_ltd-theta_ltd))"
    - "w_out = sqrt((w + sqrt(w^2))/(2*pi))"
    - "s_out = s_pre*w_out"
  variables:
    s_out: output(0.0)
    w: variable(0.0)
    w_out: variable(0.0)
    s_pre: input(0.0)
    u_pre: input(0.0)
    v_post: input(0.0)
    v_post_ltp: input(0.0)
    v_post_ltd: input(0.0)
    a_ltp: 0.1
    a_ltd: 0.1
    theta_ltp: 1.0
    theta_ltd: 1.0
    gamma_ltp: 10.0
    gamma_ltd: 10.0

# cubic Brunel rule
brunel_op:
  base: OperatorTemplate
  equations:
    - "c = u_pre + u_post"
    - "w' = (a_ltp*sigmoid(gamma_ltp*(c-theta_ltp))*(1-w) - a_ltd*sigmoid(gamma_ltd*(c-theta_ltd))*w^(1/4) - w*(1-w)*(0.5-w)) / tau_w"
    - "s_out = s_pre*w"
  variables:
    s_out: output(0.0)
    w: variable(0.0)
    c: variable(0.0)
    u_pre: input(0.0)
    u_post: input(0.0)
    s_pre: input(0.0)
    tau_w: 100.0
    W0: 0.5
    a_ltp: 0.1
    a_ltd: 0.1
    theta_ltp: 1.0
    theta_ltd: 1.0
    gamma_ltp: 10.0
    gamma_ltd: 10.0

# STDP rule
stdp_op:
  base: OperatorTemplate
  equations:
    - "ltp = p1*p2"
    - "ltd = d1*d2"
    - "w' = a*(b*((1-w)*ltp - w*ltd) + (1-b)*(ltp - ltd)*(w-w^2))"
    - "s_out = s_in*w"
  variables:
    s_out: output(0.0)
    w: variable(1.0)
    ltp: variable
    ltd: variable
    a: 0.1
    b: 0.5
    s_in: input(0.0)
    p1: input(0.0)
    p2: input(0.0)
    d1: input(0.0)
    d2: input(0.0)

# hebbian Oja's rule
oja_op:
  base: OperatorTemplate
  equations:
    - "w' = a*(r_s*r_t - r_t*r_t)"
    - "r_out = r_s*w"
  variables:
    r_out: output(0.0)
    w: variable(0.0)
    a: 0.1
    r_s: input(0.0)
    r_t: input(0.0)

# node templates
################

fre_pop:
  base: NodeTemplate
  operators:
    - fre_op
    - syn_op
    - ca_op

fre_sd_pop:
  base: NodeTemplate
  operators:
    - fre_op
    - syn_sd_op
    - ca_op

fre_sf_pop:
  base: NodeTemplate
  operators:
    - fre_op
    - syn_sf_op
    - ca_op

qif_pop:
  base: NodeTemplate
  operators:
    - qif_op
    - syn_op
    - ca_op

qif_sd_pop:
  base: NodeTemplate
  operators:
    - qif_op
    - syn_sd_op
    - ca_op

qif_sf_pop:
  base: NodeTemplate
  operators:
    - qif_op
    - syn_sf_op
    - ca_op

ik_clopath_pop:
  base: NodeTemplate
  operators:
    - ik_clopath_op

# edge templates
################

clopath_edge:
  base: EdgeTemplate
  operators:
    - clopath_op

brunel_edge:
  base: EdgeTemplate
  operators:
    - brunel_op

stdp_edge:
  base: EdgeTemplate
  operators:
    - stdp_op

oja_edge:
  base: EdgeTemplate
  operators:
    - oja_op

# circuit templates
###################

fre:
  base: CircuitTemplate
  nodes:
    p: fre_pop

fre_sd:
  base: CircuitTemplate
  nodes:
    p: fre_sd_pop

qif:
  base: CircuitTemplate
  nodes:
    p: qif_pop

qif_sd:
  base: CircuitTemplate
  nodes:
    p: qif_sd_pop
  edges:
    - [p/syn_sd_op/s, p/qif_op/s_in, null, weight: 1.0]

qif_sf:
  base: CircuitTemplate
  nodes:
    p: qif_sf_pop
  edges:
    - [p/syn_sf_op/s, p/qif_op/s_in, null, weight: 1.0]

qif_sp:
  base: CircuitTemplate
  nodes:
    p: qif_sp_pop
