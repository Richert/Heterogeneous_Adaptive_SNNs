# operator templates for nodes
##############################

# qif operator
qif_stdp_op:
  base: OperatorTemplate
  equations:
    - "r' = (Delta/(pi*tau) + 2.0*r*v) / tau"
    - "v' = (v^2 - (pi*tau*r)^2 + tau*J*s_in + eta + I_ext) / tau"
    - "s' = (r-s)/tau_s"
    - "u' = (r-u)/tau_u"
  variables:
    r: output(0.01)
    v: variable(-60.0)
    s: variable(0.0)
    u: variable(0.0)
    Delta: 0.1
    tau: 10.0
    J: 20.0
    tau_u: 100.0
    tau_s: 5.0
    eta: 0.0
    I_ext: input(0.0)
    s_in: input(0.0)

# qif operator
qif_sp_op:
  base: OperatorTemplate
  equations:
    - "r' = (Delta/(pi*tau) + 2.0*r*v) / tau"
    - "v' = (v^2 - (pi*tau*r)^2 + tau*J*s_in + eta + I_ext) / tau"
    - "s' = (a*r-s)/tau_s"
    - "a' = (1-a)/tau_a + (A0-a)*kappa*r"
    - "u' = (r-u)/tau_u"
  variables:
    r: output(0.01)
    v: variable(-60.0)
    s: variable(0.0)
    a: variable(1.0)
    u: variable(0.0)
    Delta: 0.1
    kappa: 0.0
    A0: 0.0
    tau_a: 50.0
    tau: 10.0
    J: 20.0
    tau_u: 100.0
    tau_s: 5.0
    eta: 0.0
    I_ext: input(0.0)
    s_in: input(0.0)

# qif operator
qif_sd_op:
  base: OperatorTemplate
  equations:
    - "r' = (Delta/(pi*tau) + 2.0*r*v) / tau"
    - "v' = (v^2 - (pi*tau*r)^2 + tau*J*s_in + eta + I_ext) / tau"
    - "s' = (a*r-s)/tau_s"
    - "a' = (1-a)/tau_a + (A0-a)*kappa*r"
  variables:
    r: output(0.01)
    v: variable(-60.0)
    s: variable(0.0)
    a: variable(1.0)
    Delta: 0.1
    theta: 0.5
    kappa: 0.0
    A0: 0.0
    tau_a: 50.0
    tau: 10.0
    J: 20.0
    tau_s: 5.0
    eta: 0.0
    I_ext: input(0.0)
    s_in: input(0.0)

# operator templates for edges
##############################

# hebbian STDP rule
stdp_op:
  base: OperatorTemplate
  equations:
    - "w' = a*(b*((1-w)*x_s*r_t - w*x_t*r_s) + (1-b)*(x_s*r_t - x_t*r_s)*(w-w^2))"
    - "r_out = r_s*w"
  variables:
    r_out: output(0.0)
    w: variable(1.0)
    a: 0.1
    b: 0.5
    r_s: input(0.0)
    r_t: input(0.0)
    x_s: input(0.0)
    x_t: input(0.0)

# anti-hebbian STDP rule
stdp_ah_op:
  base: OperatorTemplate
  equations:
    - "w' = a*(b*((1-w)*x_t*r_s - w*x_s*r_t) + (1-b)*(x_t*r_s - x_s*r_t)*(w-w^2))"
    - "r_out = r_s*w"
  variables:
    r_out: output(0.0)
    w: variable(1.0)
    a: 0.1
    b: 0.5
    r_s: input(0.0)
    r_t: input(0.0)
    x_s: input(0.0)
    x_t: input(0.0)

# hebbian Oja's rule
oja_op:
  base: OperatorTemplate
  equations:
    - "w' = a*(b*((1-w)*x_s*r_t - w*x_t*r_t) + (1-b)*(x_s*r_t - x_t*r_t)*(w-w^2))"
    - "r_out = r_s*w"
  variables:
    r_out: output(0.0)
    w: variable(1.0)
    a: 0.1
    b: 0.5
    r_s: input(0.0)
    r_t: input(0.0)
    x_s: input(0.0)
    x_t: input(0.0)

# anti-hebbian Oja's rule
oja_ah_op:
  base: OperatorTemplate
  equations:
    - "w' = a*(b*((1-w)*r_s*x_s - w*x_s*r_t) + (1-b)*(r_s*x_s - x_s*r_t)*(w-w^2))"
    - "r_out = r_s*w"
  variables:
    r_out: output(0.0)
    w: variable(1.0)
    a: 0.1
    b: 0.5
    r_s: input(0.0)
    r_t: input(0.0)
    x_s: input(0.0)
    x_t: input(0.0)

# node templates
################

qif_stdp_pop:
  base: NodeTemplate
  operators:
    - qif_stdp_op

qif_sp_pop:
  base: NodeTemplate
  operators:
    - qif_sp_op

qif_sd_pop:
  base: NodeTemplate
  operators:
    - qif_sd_op

# edge templates
################

stdp_edge:
  base: EdgeTemplate
  operators:
    - stdp_op

stdp_ah_edge:
  base: EdgeTemplate
  operators:
    - stdp_ah_op

oja_edge:
  base: EdgeTemplate
  operators:
    - oja_op

oja_ah_edge:
  base: EdgeTemplate
  operators:
    - oja_ah_op

# circuit templates
###################

qif_stdp:
  base: CircuitTemplate
  nodes:
    p: qif_stdp_pop

qif_sd:
  base: CircuitTemplate
  nodes:
    p: qif_sd_pop
  edges:
    - [p/qif_sd_op/s, p/qif_sd_op/s_in, null, weight: 1.0]

qif_sp:
  base: CircuitTemplate
  nodes:
    p: qif_sp_pop
